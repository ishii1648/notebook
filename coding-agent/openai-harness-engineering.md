# OpenAI "Harness Engineering" まとめ

> 出典: [Harness engineering: leveraging Codex in an agent-first world](https://openai.com/index/harness-engineering/)

---

## 概要

OpenAIチームが5ヶ月間、**手動コード記述ゼロ**という制約の下でCodexエージェントだけを使いソフトウェアプロダクトを構築・出荷した実験の知見。手書きの場合と比較して**約1/10の期間**で、約100万行のコード・約1,500PR（3人→7人チーム）を達成した。

---

## 1. 空のリポジトリからスタート

- 2025年8月下旬に空リポジトリへの最初のコミット
- リポジトリ構造、CI設定、フォーマッタ、パッケージマネージャ、アプリフレームワークの初期スキャフォールドをCodex CLI（GPT-5）で生成
- 最初の`AGENTS.md`自体もCodexが記述
- 5ヶ月後: 約100万行、約1,500PR（エンジニア1人あたり平均3.5PR/日）
- チーム拡大（3人→7人）後もスループットは向上

---

## 2. エンジニアの役割の再定義

**コードを書く人 → エージェントが働ける環境を整える人**

- 初期の進捗が遅かった原因はCodexの能力不足ではなく、**環境の未整備**
- 失敗時の対応は「もっと頑張る」ではなく「**何の能力が欠けているか？それをどうエージェントに理解・遵守させるか？**」
- エンジニアはプロンプトでタスクを記述 → Codexが実行 → PRを開く
- PRレビューもエージェント同士で完結する方向へ（Ralph Wiggum Loop）

---

## 3. アプリケーションの可読性向上

**ボトルネックは人間のQA能力** → エージェントが直接検証できる仕組みを構築

| 施策 | 詳細 |
|------|------|
| **git worktree毎のアプリ起動** | Codexが変更ごとに独立インスタンスを起動・操作 |
| **Chrome DevTools Protocol連携** | DOMスナップショット、スクリーンショット、ナビゲーションでUI検証 |
| **ローカル観測性スタック** | worktree毎にエフェメラルなログ/メトリクス/トレース環境を構築 |
| **LogQL/PromQL/TraceQL** | 「起動800ms以内」「クリティカルジャーニーのスパン2秒以内」等の定量基準をプロンプトで指定可能に |

- 単一のCodex実行が**6時間以上**継続的に作業することも（人間の睡眠中に）

---

## 4. リポジトリ知識を正式記録にする

### 巨大AGENTS.mdの失敗

| 問題 | 説明 |
|------|------|
| コンテキストは希少資源 | 巨大な指示ファイルがタスク・コード・関連ドキュメントを圧迫 |
| すべてが「重要」= 何も重要でない | エージェントが意図的にナビゲートせずローカルなパターンマッチに |
| 即座に腐敗する | 陳腐化したルールの墓場になり、メンテが止まる |
| 検証困難 | カバレッジ・鮮度・所有者・クロスリンクの機械的チェックができない |

### 解決策: AGENTS.mdは「目次」、docs/が「本体」

```
AGENTS.md          ← 約100行のマップ（目次）
ARCHITECTURE.md
docs/
├── design-docs/   ← 設計ドキュメント（インデックス付き）
├── exec-plans/    ← 実行計画（active/completed/tech-debt）
├── generated/     ← 自動生成ドキュメント
├── product-specs/ ← プロダクト仕様
├── references/    ← 外部参照（LLM向けtxt等）
├── DESIGN.md / FRONTEND.md / PLANS.md / ...
```

- **Progressive Disclosure**: エージェントは小さな安定したエントリーポイントから始め、次にどこを見るべきかを学ぶ
- **機械的な強制**: リンターとCIでクロスリンク・構造・鮮度を検証
- **doc-gardeningエージェント**: 陳腐化したドキュメントを定期スキャンし修正PRを自動生成

---

## 5. エージェントにとっての可読性が目標

**エージェントがin-contextでアクセスできないものは存在しないのと同じ**

- Google Docs、Slackスレッド、人の頭の中の知識 → エージェントには見えない
- Slackでの議論もリポジトリにMarkdownとして取り込む必要がある
- 「退屈な技術」の方がエージェントにはモデル化しやすい（composability、API安定性、学習データでの表現量）
- 外部ライブラリの不透明な挙動を回避するため、**機能のサブセットを自前実装**することも（例: p-limit的パッケージの代わりに独自のmap-with-concurrencyヘルパー）

---

## 6. アーキテクチャと「味」の強制

### レイヤードアーキテクチャ

```
Types → Config → Repo → Service → Runtime → UI
```

- ビジネスドメインごとに固定レイヤー構造、依存方向を厳格に検証
- 横断的関心事（auth、connectors、telemetry、feature flags）は**Providers**という単一インターフェースから注入
- カスタムリンター（Codex自身が生成）と構造テストで機械的に強制

### Taste Invariants（味の不変条件）

| ルール | 内容 |
|--------|------|
| 構造化ログ | 静的に強制 |
| 命名規則 | スキーマ・型の命名を統一 |
| ファイルサイズ制限 | 肥大化を防止 |
| プラットフォーム固有の信頼性要件 | カスタムリントで検証 |

- リントのエラーメッセージに**修正手順を埋め込む** → エージェントのコンテキストに自動注入
- 人間には窮屈に感じるルールも、エージェントにとっては**乗数効果**（一度エンコードすれば全箇所に適用）
- 「境界は厳格に、境界内は自由に」（大規模プラットフォーム組織のリーダーシップと同じ）
- コードが人間の好みと一致しなくても、**正しく・保守可能で・将来のエージェント実行に読みやすければOK**

---

## 7. スループットがマージ哲学を変える

- **最小限のブロッキングマージゲート**を運用
- PRは短命
- テストのflakyは無限にブロックせず、フォローアップ実行で対処
- 低スループット環境では無責任だが、エージェントのスループットが人間の注意力を大幅に超える環境では**修正は安価、待機は高価**

---

## 8. 「エージェント生成」の実際の意味

エージェントが生成するのはコードだけではない:

- プロダクトコードとテスト
- CI設定とリリースツーリング
- 内部開発者ツール
- ドキュメントと設計履歴
- 評価ハーネス
- レビューコメントとその返信
- リポジトリ自体を管理するスクリプト
- プロダクションダッシュボード定義ファイル

人間は**異なる抽象度のレイヤー**で作業: 優先順位付け、ユーザーフィードバックの受入基準への変換、成果の検証。

---

## 9. 自律性の段階的向上

単一プロンプトからエージェントが実行できるようになった一連の流れ:

1. コードベースの現在状態を検証
2. 報告されたバグを再現
3. 失敗を示す動画を記録
4. 修正を実装
5. アプリを駆動して修正を検証
6. 解決を示す動画を記録
7. PRを開く
8. エージェント・人間のフィードバックに対応
9. ビルド失敗を検出・修正
10. 判断が必要な場合のみ人間にエスカレーション
11. 変更をマージ

※このリポジトリ固有の構造・ツーリングに強く依存しており、同様の投資なしに一般化できるものではない。

---

## 10. エントロピーとガベージコレクション

### 問題

- Codexはリポジトリに既存のパターンを複製する（不均一・非最適なものも含めて）
- 時間とともに必然的に**ドリフト**が発生
- 当初は人間が毎週金曜（週の20%）を「AIスロップ」の清掃に費やしていた → スケールしない

### 解決策: Golden Principlesと自動クリーンアップ

| 原則例 | 内容 |
|--------|------|
| 共有ユーティリティの優先 | 手書きヘルパーより共有パッケージで不変条件を集中管理 |
| YOLOスタイル禁止 | データ境界はバリデーションまたは型付きSDKで検証、推測に基づく構築を排除 |

- 定期的にバックグラウンドCodexタスクが逸脱をスキャン → 品質グレード更新 → リファクタリングPRを自動生成
- ほとんどが1分以内にレビュー可能で自動マージ
- **技術的負債は高金利ローン**: 小さな増分で継続的に返済する方が、蓄積して一括対処するより遥かに良い

---

## 11. まだ学んでいること

| 未知の領域 | 内容 |
|-----------|------|
| 長期的なアーキテクチャの一貫性 | 完全エージェント生成システムが年単位でどう進化するか |
| 人間の判断の最適なレバレッジポイント | どこで人間の判断が最も価値を持ち、どうエンコードして複利的に効かせるか |
| モデルの進化への適応 | モデルがより高性能になった時、このシステムがどう変わるか |

### 結論

> ソフトウェア構築には依然として規律が必要だが、その規律は**コードよりもスキャフォールディング**に現れる。コードベースの一貫性を保つツーリング、抽象化、フィードバックループがますます重要になっている。
