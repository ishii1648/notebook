# Building a C Compiler with a Team of Parallel Claudes

- URL: https://www.anthropic.com/engineering/building-c-compiler
- 著者: Nicholas Carlini（Anthropic Safeguardsチーム研究者）
- 公開日: 2026-02-05

## Introduction

Opus 4.6を使った「エージェントチーム」でCコンパイラを構築し、その後は（ほぼ）放置した、という導入から始まる。この自律的な開発アプローチがソフトウェアエンジニアリングの未来について何を教えてくれるかを探る記事。

プロジェクトの規模感:
- 16並列のClaudeインスタンス
- 約2,000のClaude Codeセッション
- APIコスト $20,000
- 入力20億トークン、出力1.4億トークン
- 成果物: Rustベース10万行のCコンパイラ（x86/ARM/RISC-V対応、Linux 6.9コンパイル可能）

## Enabling Long-Running Claudes（長時間稼働するClaudeの実現）

通常のClaudeは1つのタスクを完了すると「入力を待って止まる」という制約がある。これを解決するため、bashループでClaudeを継続的に起動するハーネスを開発した。

```bash
while true; do
  COMMIT=$(git rev-parse --short=6 HEAD)
  claude --dangerously-skip-permissions \
         -p "$(cat AGENT_PROMPT.md)" \
         --model claude-opus-X-Y
done
```

Claudeに対しては「タスクを小さく分解し、進捗を追跡し、次に何をすべきか自分で判断する」よう指示する。1つのセッションが終わると自動的に次のセッションが立ち上がり、途切れなく作業が続く仕組み。

## Running Claude in Parallel（並列実行）

単一エージェントの限界として、**作業効率の低さ**と**専門化できない**という2つの問題がある。これを解決するため、複数のDockerコンテナに共有リポジトリをマウントし、同時並行で異なるコンポーネントの作業を行わせる。

同期の仕組み:
- `current_tasks/` ディレクトリにテキストファイルを作成してタスクを「ロック」し、重複作業を防止
- Gitのマージ機能で、複数エージェントが同じコードを変更した際のコンフリクトを解決

## Key Lessons from Agent Teams（エージェントチームからの教訓）

### テスト品質が最重要

> "Claude will work autonomously to solve whatever problem I give it. So it's important that the task verifier is nearly perfect, otherwise Claude will solve the wrong problem."
> （Claudeは与えた問題を自律的に解く。だからタスク検証器がほぼ完璧であることが重要で、さもないと間違った問題を解いてしまう）

テストが不十分だとエージェントは見当違いの方向に進む。テストは失敗モードが見つかるたびに反復的に改善された。

### コンテキストの最適化

ハーネスは大量の無駄なバイトを出力しないよう設計されている。詳細はファイルに書き出し、Claudeが必要なときだけアクセスする。エラーメッセージには`ERROR`フラグを付けてgrepしやすくし、統計情報は事前計算してClaudeが毎回再計算しなくて済むようにした。

### 時間感覚の欠如（Time Blindness）

Claudeには経過時間の感覚がなく、何時間もテストに費やしてしまう。対策として`--fast`オプションを導入し、テストスイートの1〜10%をランダムサンプリングで実行する。サンプリングはエージェントごとに決定的だが、VM間では異なるテストが選ばれるようになっている。

### 並列化戦略の転換

Linuxカーネルコンパイルという単一の巨大タスクに取り組んだ際、16エージェント全員が同じバグにぶつかるボトルネックが発生した。ここでGCCを「オンラインの既知正解コンパイラオラクル」として導入。大半のファイルはGCCでコンパイルし、自作コンパイラはファイルのサブセットでテストすることで、エージェントが異なるファイルの異なる失敗を並行してデバッグできるようにした。

### エージェントの専門化

役割を分けることで効率を上げた:
- コードの重複排除
- コンパイラのパフォーマンス最適化
- 生成コードの効率改善
- アーキテクチャの批評（Rustコード品質）
- ドキュメント整備

## Stress Testing Results（ストレステストの結果）

モデルの世代間の進歩に言及。以前のOpus 4モデルはまともに動くコンパイラすら作れなかった。Opus 4.5はテストスイートをパスできるようになったが、大規模な実プロジェクトのコンパイルは不可能だった。Opus 4.6で大幅な飛躍を達成。

コンパイル成功したプロジェクト:
- Linux 6.9（3アーキテクチャ）
- QEMU、FFmpeg、SQLite、PostgreSQL、Redis
- GCC torture testスイートで99%パス
- 究極のリトマス試験: **Doomのコンパイルと実行に成功**

## Acknowledged Limitations（認められた制約）

- **16bit x86コンパイラがない**: リアルモードのブートコードはGCCに委任。技術的には正しいコードを生成できるが、出力が60KBを超えLinuxの32KB制限に収まらないため
- **アセンブラ/リンカを持たない**: GCCの実装に依存
- **すべてのプロジェクトをコンパイルできるわけではない**: GCCの完全な代替ではない
- **生成コードの効率**: 最適化を無効にしたGCCにも劣る
- **Rustコードの品質**: 合理的だが、エキスパートプログラマーの水準には届かない

著者は「Opusの能力の限界にほぼ達している」と述べており、新機能の追加が既存機能を壊すことが頻発する状況に言及。

## Looking Forward（今後の展望）

AIとの対話的な支援から、**プロジェクト全体の自律的な完成**へとパラダイムが変わりつつあると強調。

> "Agent teams show the possibility of implementing entire, complex projects autonomously."
> （エージェントチームは、複雑なプロジェクト全体を自律的に実装する可能性を示している）

一方で慎重な懸念も表明。人間がClaudeと一緒に開発する場合は品質を保ちエラーをリアルタイムで検出できるが、自律システムでは開発者が自ら検証していないソフトウェアをデプロイするリスクがある。ペネトレーションテストのバックグラウンドを持つ著者は、「自分で検証していないソフトウェアをデプロイするプログラマーが出てくることは本当の懸念だ」と指摘。

2026年にこの能力が予想より早く到来したことへの興奮と不安の両方を認め、自律開発がスケールするにつれて新しい安全戦略が必要になると締めくくっている。
